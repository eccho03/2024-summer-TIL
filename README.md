# Study day 1
- “이것이 코딩 테스트다”  부록 A - 코딩테스트를 위한 파이썬 복습
- “이것이 코딩 테스트다” Ch3. 그리디 알고리즘 이론 공부
- “이것이 코딩 테스트다” Ch3. 그리디 알고리즘 실전 문제 1 ~ 4
- “한입 크기로 잘라 먹는 리액트” Ch5. react 실습을 위한 세팅
- “한입 크기로 잘라 먹는 리액트” Ch5. react component, jsx로 UI  표현

## 그리디 알고리즘
그리디 알고리즘은 *현재 상황에서 지금 당장 좋은 것만 고르는 방법*이다.
그리디 알고리즘의 경우 문제 출제의 폭이 매우 넓어 단순 암기로 모든 문제를 대처하기 어렵다.
이 유형은 창으리력, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다. 
어떤 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하면 된다.
1. 거스름돈 문제 : 가장 큰 화폐 단위부터 돈을 거슬러 준다.
2. 큰 수의 법칙 : 가장 큰 수를 K번 더하고 두번째로 큰 수를 한 번 더하는 연산을 반복한다.
3. 숫자 카드 게임 : 각 행마다 가장 작은 수를 찾고 그 수 중에서 가장 큰 수를 찾는다.

## React Ch 5.
`$ npm create vite@latest` 명령어를 사용해서 새로운 react 앱을 만듦
`$ npm i (혹은 npm install)`로 package에 설치되어있는 dependency를 다 설치
`$ npm run dev`로 브라우저 가동

- 자식 컴포넌트, 부모 컴포넌트,... 계층을 이루며, root 컴포넌트는 보통 App으로 세팅함
- jsx는 확장된 자바스크립트 문법으로, 함수가 html 태그를 return하는 것을 허용해줌 (js에는 문법적 오류로 판단함.)

* jsx 주의 사항
  1. 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있다.
  2. 숫자, 문자열, 배열 값만 랜더링 된다.
  3. 모든 태그는 닫혀있어야 한다.

# Study day 2
- "이것이 코딩 테스트다" Ch4. 구현 이론 공부
- "이것이 코딩 테스트다" Ch4. 구현 실전 문제 1~4
- "이것이 코딩 테스트다" Ch5. DFS/BFS 이론 공부
- "이것이 코딩 테스트다" Ch4. DFS/BFS 실전 문제 1~4
- “한입 크기로 잘라 먹는 리액트” Ch5. props
- “한입 크기로 잘라 먹는 리액트” Ch5. event 처리

## 구현
ex1. 특정 소수점 자리까지 출력해야 하는 문제, 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 파싱해야 하는 문제 등
ex2. 완전 탐색 (모든 경우의 수를 주저 없이 다 계산하는 해결 방법), 시뮬레이션 (문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행)

*메모리 접근*
- 리스트 크기가 1,000만 이상인 리스트는 메모리 용량 제한으로 풀 수 없음.
- 1초에 2천만 번 연산을 수행한다고 생각하면 됨 (파이썬 기준)
- PyPy는 파이썬3과 동일한 문법을 제공하며, 실행 속도가 더 빠르므로 코딩 테스트 환경이 Pypy3을 지원한다면 이를 활용하기.

1. 상하좌우 : 이동 계획은 `input().split()`을 사용해 한 번에 입력받기
2. 시각 : 매 시각을 문자열로 바꿔 문자열에 '3'이 포함되었는지 검사 (ex. 03시 20분 35초라면 '03'+'20'+'35'라는 문자열에 3이 포함됐는지 검사함)
3. 왕실의 나이트 : `column = int(ord(input_data[0] - int(ord('a')) + 1` -> ord : 특정 한 문자를 아스키 코드 값으로 변환해주는 함수
4. 게임 개발
   - 방향을 설정해 이동하는 문제 유형에서는, dx와 dy라는 리스트로 방향을 정함 (ex. dx[0], dy[0]만큼 더하기)
   - 맵을 0으로 초기화 : `d = [[0] * m for _ in range(n)`
   - 전체 맵 정보를 입력 받기
     ```Python
     for i in range(n):
         array.append(list(map(int, input().split())))
     ```
   - 코딩 테스트에서는 예외처리를 고려하지 않고 짜는 걸 목표로 함.

## DFS / BFS
*사전 지식*
- 스택 : 기본 리스트에서 `append()`와 `pop()` 메소드 사용
- 큐 : `from collections import deque ; queue = deque()` 사용
- 재귀 함수

*DFS*
- 인접 행렬 : 2차원 배열로 그래프 연결관계 표현
- 인접 리스트 : 리스트로 그래프 연결관계 표현 -> 파이썬에서는 단순히 2차원 리스트를 사용하여 append 해주면 된다.
  ㄴ 연결된 정보만을 저장해 메모리를 효율적으로 사용함. 정보 얻는 속도는 느림.
- 알고리즘 : 시작 노드를 스택에 삽입 후 방문 처리함. -> 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리함. 없으면 최상단 노드 꺼내기

*BFS*
- 시작 노드를 큐에 삽입 후 방문 처리함. -> 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리함.

1. 음료수 얼려 먹기 : (DFS) 특정 지점의 주변 상, 하, 좌, 우를 살펴본 뒤 주변 지점 중에서 값이 0이며 방문하지 않은 지점이 있으면 해당 지점을 방문한다. -> 방문 지점에서 다시 상, 하, 좌, 우를 살펴보며 다시 방문 진행. 
2. 미로 탈출 : (BFS 이유 : 시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색하기 때문에, 탈출하기 위한 최소한의 경로를 찾을 수 있다.) (1, 1) 지점에서부터 BFS를 수행하여 모든 노드의 값을 거리 정보로 넣는다.
   popleft : 제일 앞의 요소를 삭제함.
   
- `props`에서 부모 컴포넌트에서 자식 컴포넌트로 전달하는 것이지, 반대는 불가능함.
- 이벤트 핸들러 인자 전달 시 이름만 전달하면 됨. 함수처럼 x
- `SyntheticBaseEvent` (합성 이벤트 객체) : 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태

# Study day 3
- "이것이 코딩 테스트다" Ch6. 정렬 이론 공부
- "이것이 코딩 테스트다" Ch6. 정렬 실전 문제 1~4
- “한입 크기로 잘라 먹는 리액트” Ch5. state
- “한입 크기로 잘라 먹는 리액트” Ch5. state와 props
    
- 선택 정렬 : 매번 가장 작은 것을 선택하여 앞으로 보냄
    swap : 두 변수의 위치를 변경하는 작업(arr[0], arr[1] = arr[1], arr[0])
    시간복잡도 O(n^2)로 느림
- 삽입 정렬 : 데이터를 적절한 위치에 삽입함 (데이터가 거의 정렬 돼있을 때 효율적임)
- 퀵 정렬 : 기준(pivot)을 설정하고 큰 수와 작은 수를 교환하고 리스트를 반으로 나누는 방식
    pivot 선택 : 리스트의 1번째(가장 대표적)
    시간복잡도 O(nlogn)
- 계수정렬 : 정수 형태일 때, 데이터의 크기 범위가 제한되어있을 때만 사용 가능함. -> 각 데이터가 몇 번 등장했는지 횟수 기록 후 그 횟수만큼의 인덱스를 차례로 출력해준다.
    시간복잡도 O(N + K), 공간복잡도 O(N + K) -> 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리함.
-   만약에 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리함. (일반적인 경우 평균적으로 빠르게 동작하기 때문에)

- 파이썬의 정렬 라이브러리 : `sorted()` -> merge sort 기반 (O(nlogn))
    ex1) result = sorted(arr) 혹은 arr.sort()
    ex2) key 활용 (함수를 사용해 정렬의 기준을 만듦)
          ```Python
          def setting(data) :
            return data[1]
          result = sorted(array, key=setting)
          print(result)
          ```
- 정리) 별도 요구사항이 없을 때 : 기본 정렬 라이브러리 사용 / 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야 할 때 : 계수 정렬 활용
- 유형) (1) 정렬 라이브러리로 풀 수 있는 문제 / (2) 정렬 알고리즘의 원리에 대해서 물어보는 문제 / (3) 더 빠른 정렬이 필요한 문제

1. 위에서 아래로 : 모든 수가 100,000 이하이면 어떤 정렬 알고리즘을 사용하든 관계없다.
2. 성적이 낮은 순서로 학생 출력하기 : 학생 정보를 (점수, 이름)으로 묶은 뒤에 점수를 기준으로 정렬을 수행
   arr.append((input_data[0], int(input_data[1])))
   arr.sorted(arr, key=lambda student: student[1]) -> key 인자에 함수를 넘겨주면 우선순위가 정해짐.
3. 두 배열의 원소 교체 : 매번 배열 A에서 가장 작은 원소를 골라서 배열 B에서 가장 큰 원소와 교체. 단, 전자가 후자보다 작아야 교체하기. (K번 반복)

- `state` : 현재 가지고 있는 형태나 모양을 정의. 변화할 수 있는 동적인 값. 이 값에 따라 랜더링 되는 UI가 결정된다.
  -> 일반 변수가 아닌 `state`를 활용해야 리랜더링을 해줌.
- 리랜더링 되는 경우 : 1) 자신이 가리키는 `state`의 값이 변경됐을 때, 2) 자신이 제공받는 `props` 값이 변경됐을 때, 3) 부모 컴포넌트가 리랜더링됐을 때
- => 부모 컴포넌트가 리랜더링 됐을 때 관련된 자식 컴포넌트가 많아질 경우, 성능이 안 좋아짐 -> 서로 다른 컴포넌트로 분리해 관리함.

# Study day 4
- "이것이 코딩 테스트다" Ch7. 이진 탐색 이론 공부
- "이것이 코딩 테스트다" Ch7. 이진 탐색 실전 문제 1~4
- “한입 크기로 잘라 먹는 리액트” Ch5. state로 사용자 입력 관리

## 탐색
- 순차 탐색 : 리스트 안의 특정한 데이터를 찾기 위해 앞에서부터 차례로 데이터를 확인하는 방법 -> O(N)
- 이진 탐색 : 찾으려는 데이터와 중간점 데이터를 반복적으로 비교해 원하는 데이터를 찾음. 한 번 확인 시마다 확인하는 원소의 개수가 절반씩 줄어듦. -> O(logN)
  => 암기하는 것이 좋음

- 트리 : 그래프의 일종, 많은 양의 데이터를 관리 시 사용.
  ㄴ 이진 탐색 트리 : 부모노드를 기준으로 왼쪽 자식 노드는 더 작고, 오른쪽 자식 노드는 더 큼. => 구현하는 문제 출제 少

* 빠르게 입력받기 : 입력 데이터 개수가 많을 시 input() 함수를 사용하면 시간 초과가 될 수 있음. -> readline() 사용 (관행적으로 외울 것)
  ```Python
  import sys
  input_data = sys.stdin.readline().rstrip()
  print(input_data)
  ```

## 탐색 실전 문제
1. 부품 찾기
   1) 이진 탐색
   - 매장의 N개의 부품을 번호 순으로 정렬 -> M개의 부품이 매장에 존재하는지 검사
   - O(M * logN) + O(N * logN)
      부품 찾기  +  물품 정렬
   2) 계수 정렬
   - 모든 원소의 번호를 포함할 수 있는 크기의 리스트를 만듦 -> 리스트의 인덱스에 직접 접근해 특정 번호의 부품이 매장에 존재하는지 여부를 확인함.
     ```Python
     # n = 가게 부품 개수
     n = int(input())
     arr = [0] * 1000001 # n 제한 범위가 100만임

     # 가게 전체 부품 번호 기록
     for i in input().split():
       arr[int(i)] = 1
     # M = 손님 요청 부품 개수
     m = int(input())
     # x = 손님이 확인 요청한 전체 부품 번호
     x = list(map(input, input().split()))
     for i in x:
       # 해당 부품이 존재하는지 확인
       if arr[i] == 1:
         print('yes', end='')
       else:
         print('no', end='')
     ```
   3) 집합 자료형 활용 : `set()`을 사용해 집합 자료형 초기화. 단순히 특정 데이터가 존재하는지 검사할 때 효과적으로 이용 가능.
     ```Python
     n = int(input())
     arr = set(map(int, input().split())) # 집합 자료형 활용

     m = int(input())
     x = list(map(int, input().split()))

     for i in x:
       if i in arr:
         print('yes', end='')
       else:
         print('no', end='')
     ```

2. 떡볶이 떡 만들기
- `Parametric Search` 유형 : 최적화 문제를 결정 문제(예 또는 아니오)로 바꿔 해결하는 기법. 원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제에 주로 사용함.
- 전략 : 시작점은 0, 끝점은 가장 긴 떡의 길이로 설정 -> 중간점을 절단기 높이 H로 설정했을 때 얻을 수 있는 떡의 합을 구함 -> 필요한 떡 길이와 비교
  ```Python
  n, m = list(map(int, input().split(' ')))
  arr = list(map(int, input().split()))

  start = 0
  end = max(arr)

  result = 0
  while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in arr:
      # 자른 후 떡의 양 계산
      if x > mid:
        total += x - mid
      # -------------------
    if total < m:
      end = mid - 1
    else:
      result = mid
      start = mid + 1
  
  print(result)
  ```
## state로 사용자 입력 관리
- `place holder` : 아무것도 입력하지 않았을 때 나오는 가이드 문구
- input의 `type="date"`를 하면 날짜를 고르도록 할 수 있음.
- `<select>`, `<option>` 태그를 사용하여 여러 선택지 중 고를 수 있음. 이때 초깃값은 기본적으로 맨 위에 것이므로, 빈 옵션을 초깃값으로 설정하고 싶으면 그냥 빈 태그(`<option></option>)`)를 사용해주면 됨.
- `textarea` 사용해서 입력 부분 만들 수 있음.

# Study day 5
- "이것이 코딩 테스트다" Ch8. 다이나믹 프로그래밍 이론 공부
- "이것이 코딩 테스트다" Ch8. 다이나믹 프로그래밍 실전 문제 1~2
## 다이나믹 프로그래밍
- 메모리 공간을 활용하여 연산 속도를 비약적으로 증가시키는 방법
- 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법.
1) `top-down` : 재귀함수를 사용하는 방법
2) `bottom-up` : 반목문을 사용하는 방법
ex) 피보나치 수열

## 다이나믹 프로그래밍 실전 문제
1. 1로 만들기
   Ai = min(Ai-1, Ai/2, Ai/3, Ai/5) + 1
2. 개미전사
   식량창고를 털지 안 털지를 결정하는 경우 , 특정 i번째 식량창고를 털지 안 털지 여부
   1) i-1번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 없다.
   2) i=2번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 있다.
      둘 중 더 많은 식량을 털 수 있는 경우를 택하면 된다.

   Ai = max(Ai-1, Ai-2 + Ki)

# Study day 6
- "이것이 코딩 테스트다" Ch9. 최단 경로 이론 공부
- "이것이 코딩 테스트다" Ch9. 최단 경로 실전 문제 1~2

## 최단 경로
- 가장 짧은 경로를 찾는 알고리즘
- 1) 다익스트라 2) 플로이드 워셜

1. 다익스트라 : 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
특징) 음의 간선이 없을 때 정상적으로 동작한다.
원리) 1> 출발 노드 설정 / 2> 최단 거리 테이블 초기화 / 3> 방문하지 않은 노드 중 가장 짧은 노드 선택 / 4> 해당 노드를 거쳐 다른 노드로 가는 비용 계산 / 5> 계속 반복
구현)
1> 간단한 버전 O(V^2)-> 전체 노드 수가 5,000개 이하일 때
```Python
INF = int(1e9) # 무한을 의미 -> 10억
```
최단  거리가 가장 짧은 노드를 찾기 위해 매번 최단 거리 테이블을 선형적으로 (앞에서부터 하나씩) 탐색하는 방법(이 과정에서 O(V))

2> 개선된 버전 O(ElogV) -> 힙을 사용하여 최단거리 정보를 힙에 담아서 처리하여 가장 거리 짧은 노드를 더 빠르게 찾게 됨
힙은 직접 구현이 아닌, 라이브러리에서 제공하는 것 사용
`PriorityQueue` 보단 일반적으로 `heapq`를 사용하게 됨.
min heap을 사용함(값이 낮은 데이터가 먼저 삭제되므로 사용하기에 적합하다고 볼 수 있음)

정리하면, 현재 가장 가까운 노드를 저장할 때 priority queue를 사용한다고 볼 수 있음
(priority queue에서 node를 꺼내고 해당 node를 이미 처리한 적 있으면 무시하고 아직 처리하지 않은 node만 처리하면 된다.)

2. 플로이드 워셜 알고리즘 : 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우
 (다익스트라는 한 지점에서 다른 특정 지점까지의 최단 경로임)
O(n^3)
1> 자기 자신에서 자기 자신으로 가는 비용 0으로 초기화 / 2> 각 간선에 대한 정보를 입력받아 그 값으로 초기화 / 3> 점화식에 따라 플로이드 워셜 알고리즘 수행
Dab = min(Dab, Dak + Dkb)
  
